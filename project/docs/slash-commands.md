# Slash Commands

Система slash команд позволяет выполнять специальные действия в чате, начиная сообщение с символа `/`.

## Доступные команды

### /help [вопрос]

Получить помощь по проекту на основе локальной документации.

**Описание:**
- Выполняет RAG поиск по документации проекта
- Использует специальный system prompt для ответов о проекте
- Отвечает ТОЛЬКО на основе найденной документации
- Показывает источники информации

**Примеры использования:**

```
/help как создать новую сессию?
/help какие есть API endpoints?
/help как устроен RAG слой?
/help стиль кода для именования классов
/help что такое MCP?
```

**Как работает:**

1. Парсинг команды и извлечение вопроса
2. RAG поиск по документации (topK=10, threshold=0.3)
3. Формирование специального промпта:
   - "Ты - ассистент разработчика"
   - "Отвечай ТОЛЬКО на основе документации"
   - "Если в документации нет информации - честно скажи об этом"
4. Генерация ответа с использованием найденных фрагментов
5. Источники отображаются в UI

**Отличия от обычного сообщения:**

| Параметр | /help | Обычное сообщение |
|----------|-------|-------------------|
| RAG threshold | 0.3 (ниже) | 0.4 |
| RAG topK | 10 (больше) | 5 |
| System prompt | Специальный для документации | Обычный |
| Может отвечать вне документации | ❌ Нет | ✅ Да |

**Когда использовать /help:**
- Вопросы о структуре проекта
- Вопросы об API
- Вопросы о стиле кода
- Вопросы об архитектурных решениях
- Вопросы "как сделать X в этом проекте?"

**Когда НЕ использовать /help:**
- Общие вопросы о программировании
- Вопросы о внешних библиотеках
- Просьбы написать код
- Дебаггинг конкретных проблем

## Реализация команд

Команды обрабатываются в `ChatService.handleCommand()` перед основной логикой отправки сообщения.

```kotlin
private suspend fun handleCommand(
    sessionId: String,
    command: String,
    settings: SessionSettingsDto
): Message? {
    val parts = command.trim().split(" ", limit = 2)
    val commandName = parts[0].lowercase()

    return when (commandName) {
        "/help" -> handleHelpCommand(sessionId, parts.getOrNull(1) ?: "", settings)
        else -> null // Неизвестная команда - обработаем как обычное сообщение
    }
}
```

## Добавление новых команд

Чтобы добавить новую команду:

1. Добавьте обработку в `ChatService.handleCommand()`:

```kotlin
"/mycommand" -> handleMyCommand(sessionId, args, settings)
```

2. Реализуйте handler:

```kotlin
private suspend fun handleMyCommand(
    sessionId: String,
    args: String,
    settings: SessionSettingsDto
): Message {
    // Ваша логика

    // Создайте и сохраните ответное сообщение
    val responseMessage = Message(
        id = UUID.randomUUID().toString(),
        sessionId = sessionId,
        role = "assistant",
        content = "Результат команды",
        // ...
    )
    messageDao.insert(responseMessage)

    return responseMessage
}
```

3. Добавьте документацию в этот файл

## Планируемые команды

Возможные команды для будущих версий:

- `/search <query>` — поиск по истории сообщений
- `/models` — список доступных моделей
- `/settings` — показать текущие настройки сессии
- `/clear` — очистить историю сессии
- `/export` — экспортировать историю в файл
- `/summarize` — получить резюме текущей сессии
- `/branch` — показать текущую git ветку (уже есть через tool)

## Отличие команд от tools

**Slash команды** (`/help`):
- Вводятся пользователем явно
- Обрабатываются на сервере перед LLM
- Имеют специальную логику
- Не видны для LLM как инструменты

**Tools** (`get_git_branch`):
- Вызываются LLM автоматически через function calling
- LLM решает когда их использовать
- Описываются в JSON Schema
- Доступны через `ToolExecutor`

Пример:
- Пользователь пишет: `/help как устроен RAG?` → **команда**
- Пользователь пишет: "какая текущая ветка в git?" → LLM вызовет **tool** `get_git_branch`
